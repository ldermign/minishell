SIGNAUX : 
// ^\ envoie le signal de sortie (SIGQUIT), qui indique classiquement à 
l'application de quitter au plus vite sans rien sauvegarder ; de nombreuses 
applications ne remplacent pas le comportement par défaut, qui consiste à 
arrêter l'application immédiatement¹. Ainsi, lorsque vous appuyez sur 
Ctrl+ 4(ou tout ce qui envoie le caractère ^\) dans catou bc, aucun des deux 
ne remplace le comportement par défaut, l'application est tuée.

// Le terminal lui-même imprime la ^\partie du message : c'est une 
représentation visuelle du caractère que vous avez tapé, et le terminal est 
en mode cuit et avec l'écho activé (les caractères sont affichés par le 
terminal dès que vous les tapez, par opposition à mode sans écho où les 
caractères ne sont envoyés qu'à l'application, qui choisit ou non de les 
afficher). La Quitpartie vient de bash : il remarque que son processus 
enfant est mort à cause d'un signal d'arrêt, et c'est sa façon de vous le 
faire savoir.

// Les shells gèrent tous les signaux courants, de sorte que si vous tapez 
^\ dans un shell, vous ne tuez pas votre session, vous obtenez simplement 
une nouvelle invite, identique à ^C.




PIPE :
https://linuxhint-com.translate.goog/pipe_system_call_c/?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=op,sc


REDIRECTIONS :
https://putaindecode.io/articles/maitriser-les-redirections-shell/
https://www.pierre-giraud.com/shell-bash/redirection-gestion-flux/


EXPORT : 
https://www.tutorialspoint.com/unix_commands/export.htm

Scénario 1 : Il ne peut pas y avoir d'espaces à côté du =signe (égal)
Scénario 2 : l'attribution de la valeur d'un objet ne doit pas contenir d'espaces en plus des guillemets
Scénario 3 : l'attribution de valeurs de liste ne doit pas comporter d'espaces entre les valeurs
https://stackoverflow-com.translate.goog/questions/18042369/bash-export-not-a-valid-identifier?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=sc




int	check_if_variable_already_exist(t_env_ms **minishell, char *str)
char	*get_variable(t_env_ms **minishell, char *str)









TESTS : 

 
' '
aaaaaaaaaaaa
aaaaaaaaaaaaaaaa              fffffffffff
a a a a a a a a a a a a aa 
$PWD$PWD$PWD$PWD$PWD
$PWD$PWD$PWD$PWDD
$PWD${PWD}
$PWD$PFRE
$""
$ ""
tet t t t ytghuij    "htY"jy yruj$RPYJY   $PWD  $pijk" rt"
fhurifg3rufi """ :l;lll
echo > salut
bonjour < coucou
echo >mdr>hey>>sarace \sal"mdr"
echo <hey1<h'ey2'
echo bonjour >hey >>hey2 >>hey3
>> e
ls $HOME/Desktop
echo “$PATH”
echo "$PATH$PWD"
echo -n a '' b '' c '' d
e"ch"o bonjour
"${GYTR"
"NYR"%"$"HNTEYN"TE$NW$"
echoooo oui
ctrl \ 
ctrl D -> exit nb de fois ou error
ctrl C apres cat
echo $"FERWOP$PWD"   "" oijk
echo $"GTRE"$"GT"
echo -n
echo $?
$?




MARCHE PAS : 
nb pipe dans command
signaux dans <<   ->    seg fault
sig_error quand mauvaise commande -> a cause de exit





LEAKS
/*
$ cat
^\Quit (core dumped)
$ cat
$ cat
^C
$ echo iuok
iuok
$ frttg
*/

error parsing



SIGNAUX : 
https://openclassrooms.com/forum/sujet/probleme-sur-un-recode-de-minishell-44334
https://git.42l.fr/Fabien/minishell/src/branch/master/src/signal.c
^\  ->   fait ce que ^D doit faire
^D  ->   seg fault??
^D == EOF

ctrl C  >>>>>  ok?
ctrl D  >>>>>  ok mais pas trop
ctrl \  >>>>>  nop je crois

CTRL C
ok - ctrl-C in an empty prompt should show a new line with a new prompt
ok - ctrl-C in a prompt after you wrote some stuff should show a new line with a new prompt
ok - The buffer should be clean too, press "enter" to make sure nothing from the old line is executed.
ok - ctrl-C after running a blocking command like cat without arguments or grep “something“

CTRL D
ok - ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
ok - ctrl-D in a prompt after you wrote some stuff should not do anything
ok - ctrl-D after running a blocking command like cat without arguments or grep “something“

CTRL \
ok - ctrl-\ in an empty prompt should not do anything
ok - ctrl-\ in a prompt after you wrote some stuff should not do anything!
ok - ctrl-\ after running a blocking command like cat without arguments or grep “something“




$$              ->>>>> pas possible?




A FAIRE
options echo                                    >>>>>>  ok?
echo                                            >>>>>>  ok?
liste a l'endroit                               >>>>>>  ok?
$?                                              >>>>>>  ok?
recup redirections interpretees dans char **    >>>>>>  ok?
signal ctrl D                                   >>>>>>  ok?
signal ctrl \                                   >>>>>>  ok?
signal ctrl C quand cat                         >>>>>>  ok?
leaks parsing                                   >>>>>>  ok?
norme moi                                       >>>>>>  ok?
mettre en commun
norme liena




