SIGNAUX : 
// ^\ envoie le signal de sortie (SIGQUIT), qui indique classiquement à 
l'application de quitter au plus vite sans rien sauvegarder ; de nombreuses 
applications ne remplacent pas le comportement par défaut, qui consiste à 
arrêter l'application immédiatement¹. Ainsi, lorsque vous appuyez sur 
Ctrl+ 4(ou tout ce qui envoie le caractère ^\) dans catou bc, aucun des deux 
ne remplace le comportement par défaut, l'application est tuée.

// Le terminal lui-même imprime la ^\partie du message : c'est une 
représentation visuelle du caractère que vous avez tapé, et le terminal est 
en mode cuit et avec l'écho activé (les caractères sont affichés par le 
terminal dès que vous les tapez, par opposition à mode sans écho où les 
caractères ne sont envoyés qu'à l'application, qui choisit ou non de les 
afficher). La Quitpartie vient de bash : il remarque que son processus 
enfant est mort à cause d'un signal d'arrêt, et c'est sa façon de vous le 
faire savoir.

// Les shells gèrent tous les signaux courants, de sorte que si vous tapez 
^\ dans un shell, vous ne tuez pas votre session, vous obtenez simplement 
une nouvelle invite, identique à ^C.




PIPE :
https://linuxhint-com.translate.goog/pipe_system_call_c/?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=op,sc


REDIRECTIONS :
https://putaindecode.io/articles/maitriser-les-redirections-shell/
https://www.pierre-giraud.com/shell-bash/redirection-gestion-flux/


EXPORT : 
https://www.tutorialspoint.com/unix_commands/export.htm

Scénario 1 : Il ne peut pas y avoir d'espaces à côté du =signe (égal)
Scénario 2 : l'attribution de la valeur d'un objet ne doit pas contenir d'espaces en plus des guillemets
Scénario 3 : l'attribution de valeurs de liste ne doit pas comporter d'espaces entre les valeurs
https://stackoverflow-com.translate.goog/questions/18042369/bash-export-not-a-valid-identifier?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=sc




int	check_if_variable_already_exist(t_env_ms *minishell, char *str)
char	*get_variable(t_env_ms *minishell, char *str)









TESTS : 

 
' '
aaaaaaaaaaaa
aaaaaaaaaaaaaaaa			  fffffffffff
a a a a a a a a a a a a aa 
$PWD$PWD$PWD$PWD$PWD
$PWD$PWD$PWD$PWDD
$PWD${PWD}
$PWD$PFRE
$""
$ ""
tet t t t ytghuij	"htY"jy yruj$RPYJY   $PWD  $pijk" rt"
fhurifg3rufi """ :l;lll
echo > salut
bonjour < coucou
echo >mdr>hey>>sarace \sal"mdr"
echo <hey1<h'ey2'
echo bonjour >hey >>hey2 >>hey3
>> e
ls $HOME/Desktop
echo “$PATH”
echo "$PATH$PWD"
echo -n a '' b '' c '' d
e"ch"o bonjour
"${GYTR"
"NYR"%"$"HNTEYN"TE$NW$"
echoooo oui
ctrl \ 
ctrl D -> exit nb de fois ou error
ctrl C apres cat
echo $"FERWOP$PWD"   "" oijk
echo $"GTRE"$"GT"
echo -n
echo $?
$?
historique quand y a une erreur parsing



MARCHE PAS :
signaux dans <<   ->	seg fault
exit + sig_error



JE COMPRENDS PAS
====================================================
bash-5.0$ uijok oiuo > oui | echo oijo < oiuj  > oij 
bash: oiuj: No such file or directory
bash: uijok: command not found
====================================================
bash-5.0$ echo oiuo > oui | uio oijo < oiuj  > oij
bash: oiuj: No such file or directory




LEAKS
/*
$ cat
^\Quit (core dumped)
$ cat
$ cat
^C
$ echo iuok
iuok
$ frttg
*/


FREE
1 -> malloc
2 -> avant fill redir et fill arg
3 -> pendant fill arg avant fill redir





SIGNAUX : 
https://openclassrooms.com/forum/sujet/probleme-sur-un-recode-de-minishell-44334
https://git.42l.fr/Fabien/minishell/src/branch/master/src/signal.c
^\  ->   fait ce que ^D doit faire
^D  ->   seg fault??
^D == EOF

ctrl C  >>>>>  ok?
ctrl D  >>>>>  ok mais pas trop
ctrl \  >>>>>  nop je crois

CTRL C
ok - ctrl-C in an empty prompt should show a new line with a new prompt
ok - ctrl-C in a prompt after you wrote some stuff should show a new line with a new prompt
ok - The buffer should be clean too, press "enter" to make sure nothing from the old line is executed.
ok - ctrl-C after running a blocking command like cat without arguments or grep “something“

CTRL D
ok - ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
ok - ctrl-D in a prompt after you wrote some stuff should not do anything
ok - ctrl-D after running a blocking command like cat without arguments or grep “something“

CTRL \
ok - ctrl-\ in an empty prompt should not do anything
ok - ctrl-\ in a prompt after you wrote some stuff should not do anything!
ok - ctrl-\ after running a blocking command like cat without arguments or grep “something“






$$				->>>>> pas possible?






A FAIRE
options echo									>>>>>>	ok?
echo											>>>>>>	ok?
liste a l'endroit							 	>>>>>>	ok?
$?												>>>>>>	ok?
recup redirections interpretees dans char **	>>>>>>	ok?
signal ctrl D									>>>>>>	ok?
signal ctrl \									>>>>>>	ok?
signal ctrl C quand cat							>>>>>>	ok?
leaks parsing									>>>>>>	ok?
norme moi										>>>>>>	ok?
exec here_doc									>>>>>>	ok?
recup dernier '<<'								>>>>>>	ok?
changer list en char **							>>>>>>	ok?
free here_doc									>>>>>>	ok?
redirections									>>>>>>	ok?
sig_error
leaks
mettre en commun
norme liena






redirections -> machin< truc				>>>>>>>>	cest booooon
leak -> je trouverai jamais je pense






sig_error == 127 tout le temps
else
	{
		get_good_fd(args, ms->std.name_file, &(ms->std), pipefd);
		if (execve(path, exec_args_only, env) == -1)
		{
			printf("minishell: %s: command not found\n", args[0]);
			printf("tamereeeeeee\n");
			g_sig_error = 127;
			close(pipefd[0]);
			close(pipefd[1]);
			close_all_fd(&(ms->std));
			// exit(0); // je sais pas si ca fait de la merde quelque part mais ca marche
			return ;
		}
		g_sig_error = 0;
		close(pipefd[0]);
		close(pipefd[1]);
		// close_all_fd(&(ms->std));
		// exit(0);
	}
	close_all_fd(&(ms->std));
	// g_sig_error = 0;
	// exit(0); // sig_error marche pas
}





=========    8 bytes in 1 blocks are definitely lost in loss record 12 of 75
==89325==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==89325==    by 0x405CE1: init_here_doc (initialisations.c:43)
==89325==    by 0x405D7C: insertion (lists.c:25)
==89325==    by 0x4067C8: recup_pipe2 (recup_pipe.c:112)
==89325==    by 0x405BA7: recup_pipe (parsing.c:63)
==89325==    by 0x40595C: recup_args (parsing.c:77)
==89325==    by 0x405869: parsing (parsing.c:19)
==89325==    by 0x4014AF: loop (main.c:55)
==89325==    by 0x4015A0: main (main.c:80)



AddressSanitizer:DEADLYSIGNAL
=================================================================
==1136772==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x00000041d144 bp 0x000000000000 sp 0x7ffc1ae6de40 T0)
==1136772==The signal is caused by a READ memory access.
==1136772==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.
    #0 0x41d144 in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) (/mnt/nfs/homes/ejahan/Desktop/minishell/minishell+0x41d144)
    #1 0x4973f5 in free (/mnt/nfs/homes/ejahan/Desktop/minishell/minishell+0x4973f5)
    #2 0x4e59b6 in free_arg_to_pass /mnt/nfs/homes/ejahan/Desktop/minishell/srcs/parsing/free.c:22:3
    #3 0x4e5631 in free_list /mnt/nfs/homes/ejahan/Desktop/minishell/srcs/parsing/free.c:68:4
    #4 0x4d8780 in parsing /mnt/nfs/homes/ejahan/Desktop/minishell/srcs/parsing/parsing.c:33:3
    #5 0x4c8b17 in loop /mnt/nfs/homes/ejahan/Desktop/minishell/srcs/main.c:58:3
    #6 0x4c8e06 in main /mnt/nfs/homes/ejahan/Desktop/minishell/srcs/main.c:84:3
    #7 0x7f79e67e80b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16
    #8 0x41c39d in _start (/mnt/nfs/homes/ejahan/Desktop/minishell/minishell+0x41c39d)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (/mnt/nfs/homes/ejahan/Desktop/minishell/minishell+0x41d144) in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType)
