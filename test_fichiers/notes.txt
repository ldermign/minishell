SIGNAUX : 
// ^\ envoie le signal de sortie (SIGQUIT), qui indique classiquement à 
l'application de quitter au plus vite sans rien sauvegarder ; de nombreuses 
applications ne remplacent pas le comportement par défaut, qui consiste à 
arrêter l'application immédiatement¹. Ainsi, lorsque vous appuyez sur 
Ctrl+ 4(ou tout ce qui envoie le caractère ^\) dans catou bc, aucun des deux 
ne remplace le comportement par défaut, l'application est tuée.

// Le terminal lui-même imprime la ^\partie du message : c'est une 
représentation visuelle du caractère que vous avez tapé, et le terminal est 
en mode cuit et avec l'écho activé (les caractères sont affichés par le 
terminal dès que vous les tapez, par opposition à mode sans écho où les 
caractères ne sont envoyés qu'à l'application, qui choisit ou non de les 
afficher). La Quitpartie vient de bash : il remarque que son processus 
enfant est mort à cause d'un signal d'arrêt, et c'est sa façon de vous le 
faire savoir.

// Les shells gèrent tous les signaux courants, de sorte que si vous tapez 
^\ dans un shell, vous ne tuez pas votre session, vous obtenez simplement 
une nouvelle invite, identique à ^C.




PIPE :
https://linuxhint-com.translate.goog/pipe_system_call_c/?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=op,sc


REDIRECTIONS :
https://putaindecode.io/articles/maitriser-les-redirections-shell/
https://www.pierre-giraud.com/shell-bash/redirection-gestion-flux/


EXPORT : 
https://www.tutorialspoint.com/unix_commands/export.htm

Scénario 1 : Il ne peut pas y avoir d'espaces à côté du =signe (égal)
Scénario 2 : l'attribution de la valeur d'un objet ne doit pas contenir d'espaces en plus des guillemets
Scénario 3 : l'attribution de valeurs de liste ne doit pas comporter d'espaces entre les valeurs
https://stackoverflow-com.translate.goog/questions/18042369/bash-export-not-a-valid-identifier?_x_tr_sl=en&_x_tr_tl=fr&_x_tr_hl=fr&_x_tr_pto=sc




int	check_if_variable_already_exist(t_env_ms *minishell, char *str)
char	*get_variable(t_env_ms *minishell, char *str)









TESTS : 

 
' '
aaaaaaaaaaaa
aaaaaaaaaaaaaaaa			  fffffffffff
a a a a a a a a a a a a aa 
$PWD$PWD$PWD$PWD$PWD
$PWD$PWD$PWD$PWDD
$PWD${PWD}
$PWD$PFRE
$""
$ ""
tet t t t ytghuij	"htY"jy yruj$RPYJY   $PWD  $pijk" rt"
fhurifg3rufi """ :l;lll
echo > salut
bonjour < coucou
echo >mdr>hey>>sarace \sal"mdr"
echo <hey1<h'ey2'
echo bonjour >hey >>hey2 >>hey3
>> e
ls $HOME/Desktop
echo “$PATH”
echo "$PATH$PWD"
echo -n a '' b '' c '' d
e"ch"o bonjour
"${GYTR"
"NYR"%"$"HNTEYN"TE$NW$"
echoooo oui
ctrl \ 
ctrl D -> exit nb de fois ou error
ctrl C apres cat
echo $"FERWOP$PWD"   "" oijk
echo $"GTRE"$"GT"
echo -n
echo $?
$?
historique quand y a une erreur parsing



MARCHE PAS :
signaux dans <<   ->	seg fault
exit + sig_error



JE COMPRENDS PAS
====================================================
bash-5.0$ uijok oiuo > oui | echo oijo < oiuj  > oij 
bash: oiuj: No such file or directory
bash: uijok: command not found
====================================================
bash-5.0$ echo oiuo > oui | uio oijo < oiuj  > oij
bash: oiuj: No such file or directory




LEAKS
/*
$ cat
^\Quit (core dumped)
$ cat
$ cat
^C
$ echo iuok
iuok
$ frttg
*/


FREE
1 -> malloc
2 -> avant fill redir et fill arg
3 -> pendant fill arg avant fill redir





SIGNAUX : 
https://openclassrooms.com/forum/sujet/probleme-sur-un-recode-de-minishell-44334
https://git.42l.fr/Fabien/minishell/src/branch/master/src/signal.c
^\  ->   fait ce que ^D doit faire
^D  ->   seg fault??
^D == EOF

ctrl C  >>>>>  ok?
ctrl D  >>>>>  ok mais pas trop
ctrl \  >>>>>  nop je crois

CTRL C
ok - ctrl-C in an empty prompt should show a new line with a new prompt
ok - ctrl-C in a prompt after you wrote some stuff should show a new line with a new prompt
ok - The buffer should be clean too, press "enter" to make sure nothing from the old line is executed.
ok - ctrl-C after running a blocking command like cat without arguments or grep “something“

CTRL D
ok - ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
ok - ctrl-D in a prompt after you wrote some stuff should not do anything
ok - ctrl-D after running a blocking command like cat without arguments or grep “something“

CTRL \
ok - ctrl-\ in an empty prompt should not do anything
ok - ctrl-\ in a prompt after you wrote some stuff should not do anything!
ok - ctrl-\ after running a blocking command like cat without arguments or grep “something“






$$				->>>>> pas possible?






A FAIRE
options echo									>>>>>>  ok?
echo											>>>>>>  ok?
liste a l'endroit							 	>>>>>>  ok?
$?												>>>>>>  ok?
recup redirections interpretees dans char **	>>>>>>  ok?
signal ctrl D									>>>>>>  ok?
signal ctrl \									>>>>>>  ok?
signal ctrl C quand cat							>>>>>>  ok?
leaks parsing									>>>>>>  ok?
norme moi										>>>>>>  ok?
exec here_doc									>>>>>>	ok?
recup dernier '<<'								>>>>>>	ok?
changer list en char **							>>>>>>	ok?
free here_doc									>>>>>>	ok?
redirections									>>>>>>	ok?
sig_error
leaks
mettre en commun
norme liena









sig_error == 127 tout le temps
else
	{
		get_good_fd(args, ms->std.name_file, &(ms->std), pipefd);
		if (execve(path, exec_args_only, env) == -1)
		{
			printf("minishell: %s: command not found\n", args[0]);
			printf("tamereeeeeee\n");
			g_sig_error = 127;
			close(pipefd[0]);
			close(pipefd[1]);
			close_all_fd(&(ms->std));
			// exit(0); // je sais pas si ca fait de la merde quelque part mais ca marche
			return ;
		}
		g_sig_error = 0;
		close(pipefd[0]);
		close(pipefd[1]);
		// close_all_fd(&(ms->std));
		// exit(0);
	}
	close_all_fd(&(ms->std));
	// g_sig_error = 0;
	// exit(0); // sig_error marche pas
}

=========    8 bytes in 1 blocks are definitely lost in loss record 12 of 75
==89325==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==89325==    by 0x405CE1: init_here_doc (initialisations.c:43)
==89325==    by 0x405D7C: insertion (lists.c:25)
==89325==    by 0x4067C8: recup_pipe2 (recup_pipe.c:112)
==89325==    by 0x405BA7: recup_pipe (parsing.c:63)
==89325==    by 0x40595C: recup_args (parsing.c:77)
==89325==    by 0x405869: parsing (parsing.c:19)
==89325==    by 0x4014AF: loop (main.c:55)
==89325==    by 0x4015A0: main (main.c:80)



avec free
___________________
==114128== Syscall param execve(filename) points to unaddressable byte(s)
==114128==    at 0x49971AB: execve (syscall-template.S:78)
==114128==    by 0x401B5C: execute_cmd_execve (execve.c:69)
==114128==    by 0x401D03: execute_cmd_with_fork (execve.c:98)
==114128==    by 0x401382: command (main.c:32)
==114128==    by 0x4014DB: loop (main.c:58)
==114128==    by 0x4015B0: main (main.c:81)
==114128==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==114128== 
minishell: tughi: command not found
==114128== 
==114128== HEAP SUMMARY:
==114128==     in use at exit: 206,315 bytes in 292 blocks
==114128==   total heap usage: 520 allocs, 228 frees, 227,077 bytes allocated
==114128== 
==114128== 8 bytes in 1 blocks are definitely lost in loss record 7 of 68
==114128==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==114128==    by 0x405D01: init_here_doc (initialisations.c:43)
==114128==    by 0x405D9C: insertion (lists.c:25)
==114128==    by 0x4067E8: recup_pipe2 (recup_pipe.c:112)
==114128==    by 0x405BC7: recup_pipe (parsing.c:64)
==114128==    by 0x40597C: recup_args (parsing.c:78)
==114128==    by 0x405889: parsing (parsing.c:19)
==114128==    by 0x4014AF: loop (main.c:55)
==114128==    by 0x4015B0: main (main.c:81)
==114128== 
==114128== LEAK SUMMARY:
==114128==    definitely lost: 8 bytes in 1 blocks
==114128==    indirectly lost: 0 bytes in 0 blocks
==114128==      possibly lost: 0 bytes in 0 blocks
==114128==    still reachable: 1,661 bytes in 72 blocks
==114128==         suppressed: 204,646 bytes in 219 blocks
==114128== 
==114128== For lists of detected and suppressed errors, rerun with: -s
==114128== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)



sans free
___________________
==113625== Syscall param execve(filename) points to unaddressable byte(s)
==113625==    at 0x49971AB: execve (syscall-template.S:78)
==113625==    by 0x401B5C: execute_cmd_execve (execve.c:69)
==113625==    by 0x401CF3: execute_cmd_with_fork (execve.c:98)
==113625==    by 0x401382: command (main.c:32)
==113625==    by 0x4014DB: loop (main.c:58)
==113625==    by 0x4015B0: main (main.c:81)
==113625==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==113625== 
minishell: ytgui: command not found
==113625== 
==113625== HEAP SUMMARY:
==113625==     in use at exit: 206,415 bytes in 299 blocks
==113625==   total heap usage: 520 allocs, 221 frees, 227,077 bytes allocated
==113625== 
==113625== 6 bytes in 1 blocks are still reachable in loss record 5 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x406745: recup_pipe2 (recup_pipe.c:100)
==113625==    by 0x405BB7: recup_pipe (parsing.c:64)
==113625==    by 0x40596C: recup_args (parsing.c:78)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 6 bytes in 1 blocks are still reachable in loss record 6 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x406031: fill_arg (sep_args.c:38)
==113625==    by 0x40612E: interpret_args (sep_args.c:59)
==113625==    by 0x406279: sep_and_check_args (sep_args.c:89)
==113625==    by 0x4059D9: recup_args (parsing.c:85)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 8 bytes in 1 blocks are still reachable in loss record 9 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x405CA1: init_args (initialisations.c:32)
==113625==    by 0x405EF0: reverse_list (lists.c:69)
==113625==    by 0x40598E: recup_args (parsing.c:80)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 8 bytes in 1 blocks are still reachable in loss record 10 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x405CF1: init_here_doc (initialisations.c:43)
==113625==    by 0x409210: reverse_list_hd (list_hd.c:66)
==113625==    by 0x40A5E7: exec_here_doc (here_doc.c:104)
==113625==    by 0x4061FC: sep_and_check_args (sep_args.c:78)
==113625==    by 0x4059D9: recup_args (parsing.c:85)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 8 bytes in 1 blocks are still reachable in loss record 11 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x409A34: recup_redir (recup_redir.c:117)
==113625==    by 0x405A2C: recup_args (parsing.c:91)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 8 bytes in 1 blocks are definitely lost in loss record 12 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x405CF1: init_here_doc (initialisations.c:43)
==113625==    by 0x405D8C: insertion (lists.c:25)
==113625==    by 0x4067D8: recup_pipe2 (recup_pipe.c:112)
==113625==    by 0x405BB7: recup_pipe (parsing.c:64)
==113625==    by 0x40596C: recup_args (parsing.c:78)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 16 bytes in 1 blocks are still reachable in loss record 19 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x40622F: sep_and_check_args (sep_args.c:82)
==113625==    by 0x4059D9: recup_args (parsing.c:85)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)
==113625== 
==113625== 48 bytes in 1 blocks are still reachable in loss record 27 of 75
==113625==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==113625==    by 0x405D60: insertion (lists.c:21)
==113625==    by 0x405F16: reverse_list (lists.c:72)
==113625==    by 0x40598E: recup_args (parsing.c:80)
==113625==    by 0x405879: parsing (parsing.c:19)
==113625==    by 0x4014AF: loop (main.c:55)
==113625==    by 0x4015B0: main (main.c:81)

==113625== LEAK SUMMARY:
==113625==    definitely lost: 8 bytes in 1 blocks
==113625==    indirectly lost: 0 bytes in 0 blocks
==113625==      possibly lost: 0 bytes in 0 blocks
==113625==    still reachable: 1,761 bytes in 79 blocks
==113625==         suppressed: 204,646 bytes in 219 blocks
==113625== 
==113625== For lists of detected and suppressed errors, rerun with: -s
==113625== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
$ exit
